/*

A Collatz sequence is generated by repeatedly applying the following rules to an integer and then to each resulting integer in turn:

    If even: divide by 2.
    If odd: multiply by 3, then add 1.

The Collatz conjecture states that, for any initial positive integer, you will eventually reach the number 1.

Write a function that, for an initial positive integer n, returns a list containing 2 values:

    The number of times the Collatz rule has to be applied until you reach 1.
    The maximum number reached in the process.

Examples

collatz(17) ➞ [12, 52]
# Because 17 – 52 – 26 – 13 – 40 – 20 – 10 – 5 – 16 – 8 – 4 – 2 – 1
# takes 12 steps and 52 is the highest number reached.

collatz(6) ➞ [8, 16]

collatz(21) ➞ [7, 64]

Notes

N/A

*/

#include <assert.h>
#include <stdio.h>
#include <string.h>

typedef unsigned long long uvlong;

void
collatz(uvlong n, uvlong r[2])
{
	r[0] = 0;
	r[1] = 1;
	while (n != 1) {
		if (n > r[1])
			r[1] = n;

		if (n & 1)
			n = (n * 3) + 1;
		else
			n /= 2;

		r[0]++;
	}
}

void
test(uvlong n, uvlong r[2])
{
	uvlong p[2];

	collatz(n, p);
	printf("%llu %llu\n", p[0], p[1]);
	assert(!memcmp(r, p, sizeof(p)));
}

int
main(void)
{
	test(1, (uvlong[]){0, 1});
	test(3, (uvlong[]){7, 16});
	test(9, (uvlong[]){19, 52});
	test(27, (uvlong[]){111, 9232});
	test(81, (uvlong[]){22, 244});

	return 0;
}
