/*

Given the coordinates of four points in 2D space, return whether the four points could construct a square.

The coordinate (x,y) of a point is represented by an integer array with two integers.

Note:

All the input integers are in the range [-10000, 10000].
A valid square has four equal sides with positive length and four equal angles (90-degree angles).
Input points have no order.

*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef struct {
	int x, y;
} Point;

int
dist2(Point p1, Point p2)
{
	return (p2.y - p1.y) * (p2.y - p1.y) + (p2.x - p1.x) * (p2.x - p1.x);
}

int
check(Point p1, Point p2, Point p3, Point p4)
{
	// to be a valid square, the quad generated by the four points
	// must have the following properties:
	// 1) area is greater than 0
	// 2) all four sides are the same length
	// 3) the two diagonals are the same length
	return dist2(p1, p2) > 0 &&
	       dist2(p1, p2) == dist2(p2, p3) &&
	       dist2(p2, p3) == dist2(p3, p4) &&
	       dist2(p3, p4) == dist2(p4, p1) &&
	       dist2(p1, p3) == dist2(p2, p4);
}

int
issquare(Point p1, Point p2, Point p3, Point p4)
{
	// there are 4! ways to permute the vertices of a square since it has four sides
	// permuting them leads to the following configuration:
	// https://leetcode.com/problems/valid-square/Figures/593_Valid_Square_2.PNG
	// in the picture shown, the permutation are color coded with the same color
	// means that those vertices ordering generate the same sides and diagonals
	// there are only 3 unique colors in the table, meaning there are 3 unique cases
	// to check if it is a valid square, we just check if any one of those cases match
	// then it will be a valid square. we pick a set of vertices in that picture such that
	// the four points are in clockwise/counter-clockwise winding order
	// so the check function can just check the vertices with a preset winding order
	return check(p1, p2, p3, p4) || check(p1, p3, p2, p4) || check(p1, p2, p4, p3);
}

int
main(void)
{
	Point s1[] = {{0, 0}, {1, 1}, {1, 0}, {0, 1}};
	Point s2[] = {{1, 2}, {1, 3}, {1, 4}, {1, 5}};
	Point s3[] = {{5, 3}, {6, -4}, {-3, -2}, {-4, 7}};
	Point s4[] = {{8, 3}, {7, 8}, {2, 7}, {3, 2}};
	Point s5[] = {{3, 3}, {7, 4}, {8, 8}, {4, 7}};
	Point s6[] = {{16, 9}, {18, 22}, {21, 20}, {19, 17}};
	Point s7[] = {{4, 20}, {21, 19}, {20, 2}, {3, 3}};
	Point s8[] = {{3, 3}, {5, 2}, {6, 4}, {4, 5}};
	Point s9[] = {{-1, 2}, {3, 2}, {1, 4}, {1, 0}};
	Point s10[] = {{7, 26}, {29, 26}, {7, 4}, {29, 4}};
	Point s11[] = {{53, 22}, {68, 7}, {68, 22}, {53, 7}};

	printf("%d\n", issquare(s1[0], s1[1], s1[2], s1[3]));
	printf("%d\n", issquare(s2[0], s2[1], s2[2], s2[3]));
	printf("%d\n", issquare(s3[0], s3[1], s3[2], s3[3]));
	printf("%d\n", issquare(s4[0], s4[1], s4[2], s4[3]));
	printf("%d\n", issquare(s5[0], s5[1], s5[2], s5[3]));
	printf("%d\n", issquare(s6[0], s6[1], s6[2], s6[3]));
	printf("%d\n", issquare(s7[0], s7[1], s7[2], s7[3]));
	printf("%d\n", issquare(s8[0], s8[1], s8[2], s8[3]));
	printf("%d\n", issquare(s9[0], s9[1], s9[2], s9[3]));
	printf("%d\n", issquare(s10[0], s10[1], s10[2], s10[3]));
	printf("%d\n", issquare(s10[0], s10[3], s10[1], s10[2]));
	printf("%d\n", issquare(s11[0], s11[3], s11[1], s11[2]));

	return 0;
}
