/*

Given 4096 16-bit integers, only four of which are unique and others appeared twice (so 2050 different integers exist). Find the four uniques.

To time precisely and limit RAM usage, your program will be run on a 12MHz 8051(with 128B RAM). I'll test with a random case generated by some code to test, but we aim at the worst case, so anyone can provide other test cases.

You can answer in C or ASM, but C will likely give some extra disadvantage. The input array is placed on ROM 0xE000-0xFFFF, and output is placed on extra write-only RAM 0x00-0x07. When you finish outputting, clear P3.5.

A C code that solves the problem with bad score, to better understand the I/O way:

#include <reg51.h>
sbit P3_5 = P3^5;
unsigned int code input[4096] _at_ 0xE000;
unsigned int pdata output[4] _at_ 0x00;
void main() {
    unsigned long i;
    unsigned int j;
    unsigned char cnt, wr = 0;
    for (i=0; i<65536L; ++i) {
        cnt = 0;
        for (j=0; j<4096; ++j) {
            if (input[j] == i) ++cnt;
        }
        if (cnt==1) { // Order doesn't matter
            output[wr++] = i;     
        }
    }
    P3_5 = 0;
    while (1);
}
According to test this runs for 04:19:36.997507. Also see the example ASM solution that solve in several seconds.

For extreme push, I'll run the simulation on Proteus with such circuit: Circuit and check the time when DBT1 is actived.

You can use all ROM in 0000-DFFF.
You can assume RAM is initialized to 0.
You can use SFRs, including pins, as RAM
You don't need to jmp $ after clearing P3.5
You can write trash into outer RAM 08-FF, they'll be ignored

*/

fn main() {
    assert_eq!(dups(vec![1, 1, 1, 2, 2, 3]), vec![1, 2]);
}

fn dups(a: Vec<u16>) -> Vec<u16> {
    let mut h: [usize; 65536] = [0; 65536];
    let mut r = vec![];
    for v in a {
        let i = v as usize;
        h[i] += 1;
        if h[i] == 2 {
            r.push(v);
        }
    }
    r
}
