%{

Given a square matrix M, compute its matrix exponential exp(M), which is defined, using an extension of the Maclaurin series for exp(x) as

exp(M)=∑r=0∞Mrr!=M0+M1+1/2M2+1/6M3+⋯+1/n!Mn+⋯

where n! represents the factorial of n, and M0 is the identity matrix for the dimensions of M.

There are other ways to compute this, which you may use, as long as the result is sufficiently precise (see the rules below).
Test cases
Input 	Output

0 0
0 0

	

1.0 0.0
0.0 1.0

1 2
3 4

	

51.968956198705044 74.73656456700328
112.10484685050491 164.07380304920997

1 0
0 1

	

2.718281828459045 0.0
0.0 2.718281828459045

-10 -7
6 3

	

-0.17051293798604472 -0.22030000635390898
0.18882857687477908 0.23861564524264348

-2 16
0 7

	

0.1353352832366127 1949.3294633692833
0.0 1096.6331584284585

12 18 -5
-13 13 17
13 -6 2

	

951375.2972757841 1955306.8594829023 2179360.8077694285
376625.60116007976 774976.2125979062 863826.1366984685
773311.8986313189 1589134.8925863737 1771827.68268726

8 19 20 19
19 -18 8 -11
7 -16 17 -11
13 -15 -14 2

	

-809927951.1659397 682837927.821331 -2875315029.426385 166307199.77734298
-114105964.84866604 423320553.28643256 -1532090815.2105286 379540651.37782615
666012827.4455533 256623519.77362177 -454247177.983024 753881172.0779059
-849659694.5821244 -147765559.4347415 -39332769.14778117 -766216945.8367432

15 -17 7 -1 18 5
-20 1 -11 -11 -2 16
14 -4 -6 -8 -4 5
-18 2 -14 5 1 -11
-16 18 19 -10 -17 13
10 20 7 19 14 0

	

-84820410929.4261 -16367909783.470901 -68656483749.58916 3885773007.51203 -53912756108.37766 -68894112255.13809
190335662933.039 -38645269722.440834 127312405236.2376 -13585633716.898304 90603945063.00284 75004079839.71536
-68036952943.18438 -7733451697.302282 -53156358259.70866 3465229815.7224665 -41070570134.5761 -49564275538.3475
60712557398.76749 30529410698.827442 55820038060.925934 -1566782789.1900578 46171305388.15615 69179468777.9944
123964494616.41298 -39882807512.560074 77695806070.41081 -9798106385.28041 53080430956.84853 33312855054.34455
202240615797.98032 -49846425749.36303 132157848306.15779 -15002452609.223932 92731071983.4513 70419737049.6608

-3 3 9 -14 13 3 -19 11
-3 16 -3 -2 -16 17 -7 14
-16 -13 -19 -4 -19 -12 -19 4
-19 2 -1 -13 -1 20 -18 20
-15 -14 -17 4 -16 -7 -13 10
-1 3 -2 -18 -13 -20 -18 8
-6 5 17 4 -11 0 4 1
-7 14 4 5 -10 1 11 -1

	

-961464430.42625 -3955535120.8927402 -458113493.1060377 1262316775.4449253 1876774239.173575 -1179776408.054209 710474104.2845823 -1223811014.5581887
28955217908.989292 119124631307.93314 13796523822.599554 -38015726498.96707 -56520887984.67961 35530121226.97329 -21396437283.72946 36856280546.42262
-8410889774.023839 -34603239307.789085 -4007607155.9532456 11042781096.475042 16418151308.196218 -10320764772.97249 6215219812.505076 -10705984738.665106
10215509474.424953 42027619363.9107 4867469315.8131275 -13412092189.39047 -19940786719.11994 12535160455.72014 -7548741937.235227 13003031639.209038
-1859396787.0195892 -7649733581.4828005 -885954562.2162387 2441226246.193038 3629550445.402215 -2281610372.751828 1374002295.125188 -2366775855.5699253
449955718.5164527 1851164998.6281173 214390574.08290553 -590752899.2082579 -878315768.622139 552129374.7322844 -332495739.50407004 572740581.3608516
4056736597.835622 16689783857.791903 1932941125.9578402 -5326143353.840331 -7918773134.746702 4977893918.896973 -2997723598.294145 5163693248.841862
18572197375.577248 76407841992.77576 8849246673.162008 -24383706828.81331 -36253120255.06763 22789406560.399803 -13723910211.58447 23640014943.24763

Rules

    Your outputs must be within ±1%

of the outputs given in the test cases above
If you use a boring builtin to do most of the computation, you should add it to the Community Wiki answer, or post another more interesting method as well
You may assume M
will be square and have side length in [2,8]
The elements of M
will all be integers in [−20,20]
You may take M
as a nested array, a built-in matrix type, a flat array which is a square-number in length, or any other sensible format
Standard loopholes are forbidden
Standard I/O rules apply
This is code-golf, so the shortest code in bytes wins

%}

format long g
expm([0 0; 0 0])
expm([1 2; 3 4])
expm([1 0; 0 1])
expm([-10 -7; 6 3])
expm([-2 16; 0 7])
expm([12 18 -5; -13 13 17; 13 -6 2])
expm([8 19 20 19; 19 -18 8 -11; 7 -16 17 -11; 13 -15 -14 2])
expm([15 -17 7 -1 18 5;
	-20 1 -11 -11 -2 16;
	14 -4 -6 -8 -4 5;
	-18 2 -14 5 1 -11;
	-16 18 19 -10 -17 13;
	10 20 7 19 14 0])
expm([-3 3 9 -14 13 3 -19 11;
	-3 16 -3 -2 -16 17 -7 14;
	-16 -13 -19 -4 -19 -12 -19 4;
	-19 2 -1 -13 -1 20 -18 20;
	-15 -14 -17 4 -16 -7 -13 10;
	-1 3 -2 -18 -13 -20 -18 8;
	-6 5 17 4 -11 0 4 1;
	-7 14 4 5 -10 1 11 -1])
