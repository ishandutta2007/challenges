/*

A simple one:
Take a positive integer n less than 1000, and output the integers from 1 to n interleaved with the integers from n to 1.
You must concatenate the numbers so that they appear without any delimiters between them.

Test cases:
n = 1
11

n = 4
14233241

n = 26
12622532442352262172081991810171116121513141413151216111710189198207216225234243252261

n = 100
110029939849759669579489399210911190128913881487158616851784188319822081218022792378247725762675277428732972307131703269336834673566366537643863396240614160425943584457455646554754485349525051515052495348544755465645574458435942604161406239633864376536663567346833693270317130722973287427752676257724782379228021812082198318841785168615871488138912901191109299389479569659749839921001
This is code-golf so the shortest submission in bytes in each language wins. Explanations are encouraged.

*/

#include <assert.h>
#include <stdio.h>
#include <string.h>

char *
interleave(int n, char *b)
{
	int i, x, y;
	size_t l;

	*b = '\0';
	l = 0;
	x = 1;
	y = n;
	for (i = 0; i < 2 * n; i++) {
		if (!(i & 1))
			l += sprintf(b + l, "%d", x++);
		else
			l += sprintf(b + l, "%d", y--);
	}

	return b;
}

void
test(int n, const char *r)
{
	char b[512];

	interleave(n, b);
	printf("%s\n", b);
	assert(!strcmp(b, r));
}

int
main(void)
{
	test(1, "11");
	test(4, "14233241");
	test(26, "12622532442352262172081991810171116121513141413151216111710189198207216225234243252261");
	test(100, "110029939849759669579489399210911190128913881487158616851784188319822081218022792378247725762675277428732972307131703269336834673566366537643863396240614160425943584457455646554754485349525051515052495348544755465645574458435942604161406239633864376536663567346833693270317130722973287427752676257724782379228021812082198318841785168615871488138912901191109299389479569659749839921001");

	return 0;
}
