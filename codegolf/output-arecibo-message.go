/*

The Arecibo message is a 1974 interstellar radio message carrying basic information about humanity and Earth sent to globular star cluster M13 in the hope that extraterrestrial intelligence might receive and decipher it...
The message consisted of 1,679 binary digits, approximately 210 bytes...

The number 1,679 was chosen because it is a semiprime (the product of two prime numbers), to be arranged rectangularly as 73 rows by 23 columns.
The alternative arrangement, 23 rows by 73 columns, produces an unintelligible set of characters (as do all other X/Y formats).

    The Arecibo Message

    This is the message with color added to highlight its separate parts. The actual binary transmission carried no color information.

Source: Wikipedia

Your task is to output the Arecibo Message in the exact 23x73 arrangement shown in the image. Any of these output formats is acceptable:

    Text, using one character for ones and another for zeros (using the usual rules for row separation)
    A 2D array of two distinct values
    A 23x73 image with two distinct colors
    Aan uninterrupted stream of 1679 items of two distinct values (i.e. any of the above formats, but flat.)
    A 1679-bit integer. Indicate bit and byte order (endianness) in your solution.

For your convenience, here is a copy-pastable version (also an example output in text format):

00000010101010000000000
00101000001010000000100
10001000100010010110010
10101010101010100100100
00000000000000000000000
00000000000011000000000
00000000001101000000000
00000000001101000000000
00000000010101000000000
00000000011111000000000
00000000000000000000000
11000011100011000011000
10000000000000110010000
11010001100011000011010
11111011111011111011111
00000000000000000000000
00010000000000000000010
00000000000000000000000
00001000000000000000001
11111000000000000011111
00000000000000000000000
11000011000011100011000
10000000100000000010000
11010000110001110011010
11111011111011111011111
00000000000000000000000
00010000001100000000010
00000000001100000000000
00001000001100000000001
11111000001100000011111
00000000001100000000000
00100000000100000000100
00010000001100000001000
00001100001100000010000
00000011000100001100000
00000000001100110000000
00000011000100001100000
00001100001100000010000
00010000001000000001000
00100000001100000000100
01000000001100000000100
01000000000100000001000
00100000001000000010000
00010000000000001100000
00001100000000110000000
00100011101011000000000
00100000001000000000000
00100000111110000000000
00100001011101001011011
00000010011100100111111
10111000011100000110111
00000000010100000111011
00100000010100000111111
00100000010100000110000
00100000110110000000000
00000000000000000000000
00111000001000000000000
00111010100010101010101
00111000000000101010100
00000000000000101000000
00000000111110000000000
00000011111111100000000
00001110000000111000000
00011000000000001100000
00110100000000010110000
01100110000000110011000
01000101000001010001000
01000100100010010001000
00000100010100010000000
00000100001000010000000
00000100000000010000000
00000001001010000000000
01111001111101001111000

If your language, for some reason, has a builtin for the Arecibo Message, you may not use that builtin.

Good Luck!

UPDATE: I accepted the 05AB1E answer since it was the first one to be shorter than the original message. Don't let that dissuade you from new solutions.

UPDATE 2019-09-09: Accepted answer moved to a new 05AB1E answer, as it obsoletes the previous 05AB1E answer. Same point goes as previous update; new solutions still welcome.

*/

package main

import (
	"image"
	"image/color"
	"image/draw"
	"image/png"
	"os"
	"strings"
)

func main() {
	m := gen(arecibo, 32)
	png.Encode(os.Stdout, m)
}

func gen(str string, scl int) *image.RGBA {
	p, w, h := dim(str)

	d := image.Rect(0, 0, w*scl, h*scl)
	m := image.NewRGBA(d)
	for y := 0; y < len(p); y++ {
		for x := 0; x < len(p[y]); x++ {
			c := color.RGBA{100, 100, 100, 255}
			if p[y][x] != '0' {
				c = color.RGBA{0, 150, 0, 255}
			}

			b := color.RGBA{50, 50, 50, 255}
			r := image.Rect(x*scl, y*scl, (x+1)*scl, (y+1)*scl)
			u := r.Inset(2)

			draw.Draw(m, r, image.NewUniform(b), image.ZP, draw.Src)
			draw.Draw(m, u, image.NewUniform(c), image.ZP, draw.Src)
		}
	}

	return m
}

func dim(s string) (p []string, w, h int) {
	t := strings.Split(s, "\n")
	for i := range t {
		t[i] = strings.TrimSpace(t[i])
		if t[i] == "" {
			continue
		}
		p = append(p, t[i])
		w = max(w, len(t[i]))
	}
	h = len(p)
	return
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

const arecibo = `
00000010101010000000000
00101000001010000000100
10001000100010010110010
10101010101010100100100
00000000000000000000000
00000000000011000000000
00000000001101000000000
00000000001101000000000
00000000010101000000000
00000000011111000000000
00000000000000000000000
11000011100011000011000
10000000000000110010000
11010001100011000011010
11111011111011111011111
00000000000000000000000
00010000000000000000010
00000000000000000000000
00001000000000000000001
11111000000000000011111
00000000000000000000000
11000011000011100011000
10000000100000000010000
11010000110001110011010
11111011111011111011111
00000000000000000000000
00010000001100000000010
00000000001100000000000
00001000001100000000001
11111000001100000011111
00000000001100000000000
00100000000100000000100
00010000001100000001000
00001100001100000010000
00000011000100001100000
00000000001100110000000
00000011000100001100000
00001100001100000010000
00010000001000000001000
00100000001100000000100
01000000001100000000100
01000000000100000001000
00100000001000000010000
00010000000000001100000
00001100000000110000000
00100011101011000000000
00100000001000000000000
00100000111110000000000
00100001011101001011011
00000010011100100111111
10111000011100000110111
00000000010100000111011
00100000010100000111111
00100000010100000110000
00100000110110000000000
00000000000000000000000
00111000001000000000000
00111010100010101010101
00111000000000101010100
00000000000000101000000
00000000111110000000000
00000011111111100000000
00001110000000111000000
00011000000000001100000
00110100000000010110000
01100110000000110011000
01000101000001010001000
01000100100010010001000
00000100010100010000000
00000100001000010000000
00000100000000010000000
00000001001010000000000
01111001111101001111000
`
