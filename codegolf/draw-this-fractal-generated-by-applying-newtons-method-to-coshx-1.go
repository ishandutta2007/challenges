/*

I came across this picture the other day: (Credit to Josep M Batlle I Ferrer)

Your job is to generate this picture. This graph is generated by repeatedly applying newton's method to the graph of:

f(x)=cosh(x)âˆ’1

In other words, repeatedly apply the following function to every point till the rectangular distance is less than some limit to a attractor:

g(x)=(x*sinh(x) - cosh(x)+1)  / sinh(x)

The process is described in psuedocode below:

let n be the maximum number of iterations
for every point (as a complex number) in the image:
    repeat n times:
        point = (point * sinh(point) - cosh(point) + 1) / sinh(point)

        if the rectangular distance between the point and any attractor is less than 0.01:
             break
        end if
    end repeat
    color the point in the image depending on the nearest attractor and the number of iterations required
The rectangular distance is defined as max(abs(dx), abs(dy)). We use rectangular distance instead of straight line distance so we get the wave shapes that make this graph so beautiful.

There is a attractor at 0+n*2i*PI for any integer N. Thus at even increments of 2 PI in the imaginary direction.

Rules
Your graph must include the area from [-0.75, -0.75 + PI] to [0.75, +0.75 + PI].
Resolution over this needs to be at least 256 by 256. Either characters or pixels. If you decide to cover a larger area you need to increase the resolution in proportion.
Use at least 20 iterations.
Both adjacent iteration counts and adjacent attractors need to be drawn in distinct colors. You must use at least 3 different colors. Coloring should soley be based on the attractor and iteration count.
If any point causes a division by 0 or another math error, you may choose to render anything at this point. This is considered undefined behavior.
Displaying a image, saving a image, or drawing ASCII art are all acceptable, as long as the other rules are met. If you draw ASCII art characters need to be ANSI colored.
Please include a screenshot of the result in your answer
This is code golf, shortest answer wins. ASCII art answers do not compete against graphical answers in the same language.

Background info
Newton's method
Newton's fractal
Hyperbolic Trignometry

*/

package main

import (
	"flag"
	"image"
	"image/color/palette"
	"image/png"
	"math"
	"math/cmplx"
	"os"
)

func main() {
	var (
		width, height  int
		x0, y0, x1, y1 float64
	)
	flag.IntVar(&width, "width", 800, "specify width")
	flag.IntVar(&height, "height", 800, "specify height")
	flag.Float64Var(&x0, "x0", -0.75, "specify x0")
	flag.Float64Var(&y0, "y0", -0.75+math.Pi, "specify y0")
	flag.Float64Var(&x1, "x1", 0.75, "specify x1")
	flag.Float64Var(&y1, "y1", 0.75+math.Pi, "specify y1")
	flag.Parse()

	m := gen(width, height, x0, y0, x1, y1, 20)
	png.Encode(os.Stdout, m)
}

func gen(w, h int, x0, y0, x1, y1 float64, n int) *image.RGBA {
	r := image.Rect(0, 0, w, h)
	m := image.NewRGBA(r)
	for y := 0; y < h; y++ {
		for x := 0; x < w; x++ {
			px := remap(float64(x), 0, float64(w), x0, x1)
			py := remap(float64(y), 0, float64(h), y0, y1)
			pal := sample(px, py, n)
			if pal < 0 {
				pal = 0
			}
			m.Set(x, y, palette.Plan9[pal*10])
		}
	}
	return m
}

/*

@Dingus:
g(x) can be simplified to x-coth(x)+csch(x)
max(abs(dx), abs(dy)) < t implies
abs(dx) < t and abs(dy) < t so we can treat the two constants separately
dx = abs(x - 0) = abs(x) so x*x < t*t
dy = abs(y - 2*k*pi) for some integer k implies that the attractors occur when cos(x) is maximal, ie, cos(2*k*pi) = 1
so the constraint becomes
cos(abs(y - 2*k*pi)) > cos(t) which simplifies to cos(y) > cos(t) by symmetry and periodicity of cosine

*/
func sample(x, y float64, n int) int {
	const (
		eps = 1e-2
	)

	z := complex(x, y)
	for i := 0; i < n; i++ {
		z = z - coth(z) + csch(z)
		zr := real(z)
		zi := imag(z)
		if zr*zr < eps*eps && math.Cos(zi) > math.Cos(eps) {
			return i
		}
	}
	return -1
}

func coth(z complex128) complex128 {
	return 1 / cmplx.Tanh(z)
}

func csch(z complex128) complex128 {
	return 1 / cmplx.Sinh(z)
}

func lerp(t, a, b float64) float64 {
	return a + t*(b-a)
}

func unlerp(t, a, b float64) float64 {
	return (t - a) / (b - a)
}

func remap(x, a, b, c, d float64) float64 {
	return lerp(unlerp(x, a, b), c, d)
}
